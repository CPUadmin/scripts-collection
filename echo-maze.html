<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
<title>EchoMaze — сонар-лабиринт</title>
<style>
  :root{
    --bg:#090a12; --bg2:#0f1224; --panel:#131834; --panel2:#1b2248;
    --ink:#e7ebff; --ink2:#a8b4ff; --accent:#7aa3ff; --good:#9af7b0; --warn:#ffcc88;
  }
  *{box-sizing:border-box}
  html,body{height:100%;}
  body{
    margin:0; background:
      radial-gradient(1000px 600px at 65% -10%, #1b2458 0%, transparent 60%),
      radial-gradient(800px 400px at 20% -20%, #0e1542 0%, transparent 60%),
      var(--bg);
    color:var(--ink); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
    overflow:hidden;
  }
  #ui{
    position:fixed; inset:12px 12px auto 12px;
    display:flex; gap:10px; align-items:center; flex-wrap:wrap; z-index:10;
  }
  .btn{
    border:1px solid rgba(255,255,255,.15);
    background:linear-gradient(180deg, #2a376e, #1b2550);
    color:var(--ink); font-weight:700; padding:8px 12px; border-radius:12px; cursor:pointer;
  }
  .btn.small{ padding:6px 8px; font-weight:600; }
  .btn.primary{ background:linear-gradient(180deg,#3d67ff,#2b4ed3); }
  .pill{ padding:6px 10px; border-radius:999px; background:rgba(255,255,255,.08); border:1px solid rgba(255,255,255,.1); }
  #hud{ margin-left:auto; display:flex; gap:8px; align-items:center; }
  #overlay{
    position:fixed; inset:0; display:flex; align-items:center; justify-content:center;
    background:linear-gradient(180deg, rgba(0,0,0,.70), rgba(0,0,0,.55));
    z-index:20; transition:opacity .25s ease;
  }
  #overlay.hidden{ opacity:0; pointer-events:none; }
  .card{
    width:min(740px, calc(100% - 32px));
    background:linear-gradient(180deg,var(--panel),var(--panel2));
    border:1px solid rgba(255,255,255,.1); border-radius:18px; padding:18px;
    box-shadow: 0 20px 50px rgba(0,0,0,.40);
  }
  .title{ display:flex; align-items:center; justify-content:space-between; gap:12px; }
  h1{ font-size:22px; margin:0 0 8px; }
  .subtitle{ opacity:.8; margin-bottom:12px; }
  .grid2{ display:grid; grid-template-columns:1fr 1fr; gap:14px; }
  @media (max-width:700px){ .grid2{ grid-template-columns:1fr; } }
  ul{ margin:8px 0 0 18px; }
  code,kbd{ background:#0e1536; border:1px solid rgba(255,255,255,.12); padding:.15em .4em; border-radius:6px; }
  kbd{font-weight:700}
  #c{ position:fixed; inset:0; width:100vw; height:100vh; display:block; }
  #touch{ position:fixed; inset:auto 12px 12px auto; z-index:10; display:flex; gap:8px; }
  .dpad{ display:grid; grid-template-areas:". up ." "left . right" ". down ."; gap:6px; }
  .dpad button{ width:48px; height:48px; border-radius:10px; background:rgba(255,255,255,.08); color:var(--ink); border:1px solid rgba(255,255,255,.12); }
  .dpad .up{ grid-area: up;} .dpad .down{ grid-area: down;} .dpad .left{ grid-area: left;} .dpad .right{ grid-area: right;}
</style>
</head>
<body>
<canvas id="c"></canvas>

<div id="ui">
  <button id="btnStart" class="btn primary">Старт / Restart</button>
  <button id="btnPing" class="btn">Эхо (пробел/клик)</button>
  <button id="btnHelp" class="btn small">Справка (H)</button>
  <div id="hud">
    <div class="pill">Эхо: <b id="echoCount">0</b></div>
    <div class="pill">Время: <b id="time">0.0</b>s</div>
    <div class="pill">Лучшее: <b id="best">—</b></div>
  </div>
</div>

<div id="touch">
  <div class="dpad">
    <button class="up"   data-dir="up">▲</button>
    <button class="left" data-dir="left">◀</button>
    <button class="right" data-dir="right">▶</button>
    <button class="down" data-dir="down">▼</button>
  </div>
</div>

<div id="overlay" class="">
  <div class="card">
    <div class="title">
      <h1>EchoMaze — игра «сонар»</h1>
      <button id="btnCloseOverlay" class="btn small">Играть</button>
    </div>
    <div class="subtitle">Ты в тьме. Видимость — почти ноль. Посылай «эхо», чтобы на секунду увидеть стены и найти выход.</div>
    <div class="grid2">
      <div>
        <p><b>Управление</b></p>
        <ul>
          <li><kbd>WASD</kbd>/<kbd>Стрелки</kbd> — движение</li>
          <li><kbd>Space</kbd> / клик по экрану — послать «эхо»</li>
          <li><kbd>R</kbd> — рестарт, <kbd>H</kbd> — показать подсказку</li>
        </ul>
      </div>
      <div>
        <p><b>Правила</b></p>
        <ul>
          <li>Чем меньше «эхо», тем «чище» прохождение.</li>
          <li>Засекаем время. Лучший результат сохраняется локально.</li>
          <li>Выход подсвечивается только при эхо или рядом.</li>
        </ul>
      </div>
    </div>
  </div>
</div>

<script>
(function(){
  // ====== Helpers ======
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const lerp = (a,b,t)=>a+(b-a)*t;
  const rand = (n)=>Math.floor(Math.random()*n);

  // ====== Audio (pure WebAudio, no deps) ======
  const Audio = (()=>{
    let ctx;
    function ensure(){ if(!ctx){ const AC=window.AudioContext||window.webkitAudioContext; try{ ctx=new AC(); }catch{} } return ctx; }
    function beep({freq=440, dur=0.12, type='sine', vol=0.02, attack=0.005, release=0.06}){
      const c=ensure(); if(!c) return;
      const o=c.createOscillator(), g=c.createGain();
      o.type=type; o.frequency.value=freq;
      g.gain.value=0; o.connect(g); g.connect(c.destination);
      const t=c.currentTime;
      g.gain.linearRampToValueAtTime(0, t);
      g.gain.linearRampToValueAtTime(vol, t+attack);
      g.gain.exponentialRampToValueAtTime(0.0001, t+attack+dur+release);
      o.start(); o.stop(t+attack+dur+release+0.01);
    }
    function ping(){
      // три близких тона для "эхо"
      beep({freq:420, dur:0.05, type:'sine', vol:0.03});
      setTimeout(()=>beep({freq:520, dur:0.06, type:'sine', vol:0.025}), 35);
      setTimeout(()=>beep({freq:360, dur:0.05, type:'sine', vol:0.02}), 65);
    }
    function step(){
      beep({freq:200, dur:0.03, type:'triangle', vol:0.015});
    }
    function win(){
      beep({freq:660, dur:0.12, type:'square', vol:0.04});
      setTimeout(()=>beep({freq:880, dur:0.12, type:'square', vol:0.035}),120);
      setTimeout(()=>beep({freq:990, dur:0.2, type:'square', vol:0.03}),240);
    }
    return {ping, step, win};
  })();

  // ====== Maze generation (recursive backtracker) ======
  function generateMaze(cols, rows){
    const N=0, E=1, S=2, W=3;
    const dx=[0,1,0,-1], dy=[-1,0,1,0], opp=[S,W,N,E];
    const cellWalls = Array.from({length:rows}, ()=>Array.from({length:cols}, ()=>[true,true,true,true])); // N,E,S,W
    const vis = Array.from({length:rows}, ()=>Array(cols).fill(false));
    const stack=[]; let cx=0, cy=0, visited=1; vis[0][0]=true;
    while(visited<cols*rows){
      const ns=[];
      for(let d=0; d<4; d++){
        const nx=cx+dx[d], ny=cy+dy[d];
        if(nx>=0 && nx<cols && ny>=0 && ny<rows && !vis[ny][nx]) ns.push(d);
      }
      if(ns.length){
        const d=ns[rand(ns.length)];
        const nx=cx+dx[d], ny=cy+dy[d];
        cellWalls[cy][cx][d]=false;
        cellWalls[ny][nx][opp[d]]=false;
        stack.push([cx,cy]);
        cx=nx; cy=ny; vis[cy][cx]=true; visited++;
      } else if(stack.length){
        [cx,cy]=stack.pop();
      } else break;
    }
    return cellWalls; // bool[rows][cols][4]
  }

  // Build wall segments from maze for rendering
  function buildSegments(cellWalls, cellSize){
    const rows=cellWalls.length, cols=cellWalls[0].length;
    const segs=[]; // {x1,y1,x2,y2,mx,my}
    for(let y=0;y<rows;y++){
      for(let x=0;x<cols;x++){
        const [N,E,S,W]=cellWalls[y][x];
        const x0 = x*cellSize, y0=y*cellSize, x1=(x+1)*cellSize, y1=(y+1)*cellSize;
        if(N){ const sx=x0, sy=y0, ex=x1, ey=y0; segs.push({x1:sx,y1:sy,x2:ex,y2:ey,mx:(sx+ex)/2,my:(sy+ey)/2}); }
        if(S){ const sx=x0, sy=y1, ex=x1, ey=y1; segs.push({x1:sx,y1:sy,x2:ex,y2:ey,mx:(sx+ex)/2,my:(sy+ey)/2}); }
        if(W){ const sx=x0, sy=y0, ex=x0, ey=y1; segs.push({x1:sx,y1:sy,x2:ex,y2:ey,mx:(sx+ex)/2,my:(sy+ey)/2}); }
        if(E){ const sx=x1, sy=y0, ex=x1, ey=y1; segs.push({x1:sx,y1:sy,x2:ex,y2:ey,mx:(sx+ex)/2,my:(sy+ey)/2}); }
      }
    }
    return segs;
  }

  // ====== Game state ======
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  let DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));

  const UI = {
    overlay: document.getElementById('overlay'),
    btnCloseOverlay: document.getElementById('btnCloseOverlay'),
    btnStart: document.getElementById('btnStart'),
    btnPing: document.getElementById('btnPing'),
    btnHelp: document.getElementById('btnHelp'),
    echoCount: document.getElementById('echoCount'),
    time: document.getElementById('time'),
    best: document.getElementById('best'),
    dpad: document.getElementById('touch'),
  };

  const DPAD = Array.from(document.querySelectorAll('#touch .dpad button'));

  let gridCols=21, gridRows=15, cellSize=48;
  let maze, segs;
  let player = { gx:0.5, gy:0.5, tx:0.5, ty:0.5, moving:false }; // grid coords (cell-based)
  let exitCell = {x:0, y:0};
  let startTime=0, timeNow=0, running=false, echoes=0, best=null, won=false, lastStepSound=0;
  const waves=[]; // sonar waves: {x,y,t0}
  const seen = new Set(); // visited cells string "x,y" for faint breadcrumbs

  const params = {
    waveSpeed: 800,       // px/s
    waveBand: 22,         // thickness of ring
    waveFade: 1200,       // ms until wave fully fades
    nearLight: 80,        // px soft ambient around player
    playerSpeed: 3.5,     // cells per second
  };

  // ====== Init / Resize ======
  function fit(){
    const W = canvas.clientWidth  = window.innerWidth;
    const H = canvas.clientHeight = window.innerHeight;
    DPR = Math.max(1, Math.min(2, window.devicePixelRatio||1));
    canvas.width  = Math.floor(W*DPR);
    canvas.height = Math.floor(H*DPR);

    // choose grid by target cell size ~ 42..56 px
    const target = 50;
    gridCols = Math.max(9, Math.floor(W / target));
    gridRows = Math.max(9, Math.floor(H / target));
    // prefer odd for nicer mazes
    if(gridCols % 2 === 0) gridCols--;
    if(gridRows % 2 === 0) gridRows--;
    cellSize = Math.floor(Math.min(W/gridCols, H/gridRows));

    // (Re)gen level
    newLevel();
  }

  function newLevel(){
    maze = generateMaze(gridCols, gridRows);
    segs = buildSegments(maze, cellSize);
    player = { gx:0.5, gy:0.5, tx:0.5, ty:0.5, moving:false };
    exitCell = { x: gridCols-1 + 0.5, y: gridRows-1 + 0.5 };
    waves.length=0; echoes=0; running=true; won=false; startTime=performance.now(); seen.clear();
    UI.echoCount.textContent = echoes;
    if(best==null){
      const s=localStorage.getItem('echoMazeBest');
      if(s){ try{ best=JSON.parse(s) }catch{} }
    }
    UI.best.textContent = best? `${best.time.toFixed(1)}s · эхо ${best.echoes}` : '—';
    UI.overlay.classList.add('hidden');
  }

  window.addEventListener('resize', ()=>{
    // preserve timer/echoes across resize: rebuild but keep stats
    const keepEcho=echoes, keepStart=startTime;
    fit();
    echoes = keepEcho; startTime = keepStart;
    UI.echoCount.textContent = echoes;
  });

  // ====== Controls ======
  const keys = { ArrowUp:false, ArrowDown:false, ArrowLeft:false, ArrowRight:false, KeyW:false, KeyA:false, KeyS:false, KeyD:false };
  window.addEventListener('keydown', (e)=>{
    if(e.repeat) return;
    keys[e.code] = true;
    if(e.code==='Space'){ e.preventDefault(); doPing(); }
    if(e.code==='KeyH'){ toggleHelp(); }
    if(e.code==='KeyR'){ newLevel(); }
  });
  window.addEventListener('keyup', (e)=>{ keys[e.code] = false; });

  UI.btnStart.addEventListener('click', newLevel);
  UI.btnPing.addEventListener('click', doPing);
  UI.btnHelp.addEventListener('click', toggleHelp);
  UI.btnCloseOverlay.addEventListener('click', ()=>{ UI.overlay.classList.add('hidden'); });

  canvas.addEventListener('pointerdown', (e)=>{
    // tap = ping, long press could be ignored; simple ping
    doPing();
  });

  DPAD.forEach(btn=>{
    let t;
    btn.addEventListener('pointerdown', (e)=>{ e.preventDefault(); press(btn.dataset.dir); t=setInterval(()=>press(btn.dataset.dir), 140); });
    btn.addEventListener('pointerup',   ()=>{ clearInterval(t); });
    btn.addEventListener('pointerleave',()=>{ clearInterval(t); });
  });

  function toggleHelp(){
    const h = UI.overlay;
    h.classList.toggle('hidden');
  }

  function press(dir){
    if(!running) return;
    const cgx = player.gx, cgy = player.gy;
    const cx = Math.floor(cgx), cy = Math.floor(cgy);
    if(player.moving) return;
    const walls = maze[cy][cx]; // N,E,S,W
    if(dir==='up' && !walls[0]) { player.ty = cgy-1; player.tx=cgx; player.moving=true; }
    if(dir==='right' && !walls[1]) { player.tx = cgx+1; player.ty=cgy; player.moving=true; }
    if(dir==='down' && !walls[2]) { player.ty = cgy+1; player.tx=cgx; player.moving=true; }
    if(dir==='left' && !walls[3]) { player.tx = cgx-1; player.ty=cgy; player.moving=true; }
  }

  function tryMoveByKeys(){
    if(player.moving) return;
    const dir = (keys.KeyW||keys.ArrowUp) ? 'up' :
                (keys.KeyS||keys.ArrowDown) ? 'down' :
                (keys.KeyA||keys.ArrowLeft) ? 'left' :
                (keys.KeyD||keys.ArrowRight) ? 'right' : null;
    if(dir) press(dir);
  }

  function doPing(){
    if(!running) return;
    const px = player.gx*cellSize, py = player.gy*cellSize;
    waves.push({ x:px, y:py, t0: performance.now() });
    echoes++; UI.echoCount.textContent = echoes;
    Audio.ping();
  }

  // ====== Update & Render ======
  function update(dt){
    if(!running) return;
    tryMoveByKeys();
    if(player.moving){
      const speed = params.playerSpeed * dt; // in cells
      const dx = player.tx - player.gx;
      const dy = player.ty - player.gy;
      const dist = Math.hypot(dx,dy);
      const step = Math.min(speed, dist);
      if(dist < 1e-3){
        player.gx = player.tx; player.gy = player.ty; player.moving=false;
      } else {
        player.gx += (dx/dist) * step;
        player.gy += (dy/dist) * step;
        // step sound every ~0.22s
        const now = performance.now();
        if(now - lastStepSound > 220){ Audio.step(); lastStepSound = now; }
      }
    }
    // win?
    const px = player.gx*cellSize, py = player.gy*cellSize;
    const ex = exitCell.x*cellSize, ey = exitCell.y*cellSize;
    if(Math.hypot(px-ex, py-ey) < cellSize*0.35 && !won){
      won = true; running=false;
      Audio.win();
      const tsec = (performance.now()-startTime)/1000;
      // best by time then echoes
      if(!best || tsec < best.time || (Math.abs(tsec-best.time)<1e-6 && echoes<best.echoes)){
        best = { time:tsec, echoes };
        localStorage.setItem('echoMazeBest', JSON.stringify(best));
      }
      UI.best.textContent = `${best.time.toFixed(1)}s · эхо ${best.echoes}`;
      setTimeout(()=>{
        UI.overlay.classList.remove('hidden');
        UI.overlay.querySelector('.subtitle').textContent = `Финиш! Время ${tsec.toFixed(1)}s · Эхо ${echoes}. Нажми «Играть» для нового забега.`;
      }, 350);
    }
    timeNow = (performance.now()-startTime)/1000;
    UI.time.textContent = timeNow.toFixed(1);

    // remember cell
    seen.add(\`\${Math.floor(player.gx)},\${Math.floor(player.gy)}\`);
  }

  function render(){
    const W=canvas.width, H=canvas.height;
    ctx.clearRect(0,0,W,H);
    ctx.save();
    ctx.scale(DPR,DPR);

    // subtle star field background
    noiseBG(ctx, canvas.clientWidth, canvas.clientHeight);

    // Ambient near player
    const px = player.gx*cellSize, py = player.gy*cellSize;
    const grad = ctx.createRadialGradient(px,py,6, px,py, params.nearLight);
    grad.addColorStop(0, 'rgba(255,255,255,0.25)');
    grad.addColorStop(1, 'rgba(255,255,255,0.00)');
    ctx.fillStyle = grad;
    ctx.beginPath(); ctx.arc(px,py, params.nearLight, 0, Math.PI*2); ctx.fill();

    // Echo waves
    const now = performance.now();
    // compute bright for segments by ping rings
    const ringBand = params.waveBand;
    const ringSpeed = params.waveSpeed;
    // draw waves rings visuals
    for(let i=0;i<waves.length;i++){
      const w = waves[i];
      const age = now - w.t0;
      const r = (age/1000) * ringSpeed;
      const alpha = clamp(1 - age/params.waveFade, 0, 1);
      if(alpha<=0){ waves.splice(i,1); i--; continue; }
      ctx.strokeStyle = \`rgba(160,200,255,\${0.08*alpha})\`;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(w.x, w.y, r, 0, Math.PI*2);
      ctx.stroke();
    }

    // Walls lit by rings / near-light / breadcrumbs
    ctx.lineCap='square'; ctx.lineJoin='miter';
    for(const s of segs){
      // near light
      const dPlayer = Math.hypot(px - s.mx, py - s.my);
      let a = dPlayer < params.nearLight ? lerp(0.25, 0.05, dPlayer/params.nearLight) : 0;

      // sonar rings contribution (use midpoint approximation)
      for(const w of waves){
        const age = now - w.t0;
        const r = (age/1000) * ringSpeed;
        const d = Math.hypot(w.x - s.mx, w.y - s.my);
        const closeness = 1 - Math.min(1, Math.abs(d - r) / ringBand);
        if(closeness>0){
          const fade = clamp(1 - age/params.waveFade, 0, 1);
          a = Math.max(a, closeness * 0.85 * fade);
        }
      }

      if(a>0){
        ctx.strokeStyle = \`rgba(210,225,255,\${a})\`;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(s.x1, s.y1); ctx.lineTo(s.x2, s.y2);
        ctx.stroke();
      }
    }

    // Breadcrumbs (visited cells)
    ctx.fillStyle = 'rgba(140,180,255,0.08)';
    for(const tag of seen){
      const [cx, cy] = tag.split(',').map(Number);
      ctx.fillRect(cx*cellSize+cellSize*0.35, cy*cellSize+cellSize*0.35, cellSize*0.3, cellSize*0.3);
    }

    // Exit hint: only visible under near-light or echo
    const ex = exitCell.x*cellSize, ey = exitCell.y*cellSize;
    let showExit = Math.hypot(px-ex, py-ey) < params.nearLight;
    if(!showExit){
      for(const w of waves){
        const age = now - w.t0; const r=(age/1000)*ringSpeed;
        const d = Math.hypot(w.x-ex, w.y-ey);
        if(Math.abs(d - r) < params.waveBand*1.4){ showExit=true; break; }
      }
    }
    if(showExit){
      const t = now*0.002;
      const rr = cellSize*0.28 + Math.sin(t)*cellSize*0.03;
      ctx.strokeStyle = 'rgba(120,255,170,0.9)';
      ctx.lineWidth=3;
      ctx.beginPath(); ctx.arc(ex, ey, rr, 0, Math.PI*2); ctx.stroke();
      ctx.lineWidth=1.5; ctx.strokeStyle='rgba(120,255,170,0.25)';
      ctx.beginPath(); ctx.arc(ex, ey, rr+5, 0, Math.PI*2); ctx.stroke();
    }

    // Player
    ctx.fillStyle = '#ffffff';
    ctx.beginPath();
    ctx.arc(px, py, Math.max(3, cellSize*0.14), 0, Math.PI*2);
    ctx.fill();
    ctx.strokeStyle='rgba(255,255,255,0.4)'; ctx.lineWidth=1;
    ctx.beginPath(); ctx.arc(px, py, Math.max(3, cellSize*0.18), 0, Math.PI*2); ctx.stroke();

    ctx.restore();
  }

  // Subtle background dots
  function noiseBG(ctx, W, H){
    const step=64; ctx.fillStyle='rgba(255,255,255,0.03)';
    for(let y=0;y<H;y+=step){
      for(let x=0;x<W;x+=step){
        const a = (Math.sin(x*0.021 + performance.now()*0.0007) + Math.cos(y*0.017 + performance.now()*0.0005))*0.5*0.03 + 0.02;
        ctx.fillStyle = \`rgba(200,220,255,\${a})\`;
        ctx.fillRect(x+ (x%3), y+(y%5), 1, 1);
      }
    }
  }

  // ====== Main loop ======
  let last = performance.now();
  function loop(t){
    const dt = Math.min(0.1, (t-last)/1000); last=t;
    update(dt);
    render();
    requestAnimationFrame(loop);
  }

  fit();
  requestAnimationFrame(loop);

  // Start with help open
  UI.overlay.classList.remove('hidden');
})();
</script>
</body>
</html>
